
package parser

// Autogenerated code from ole_profile.json. Do not edit.

import (
    "encoding/binary"
    "fmt"
    "bytes"
    "io"
    "sort"
    "strings"
    "unicode/utf16"
    "unicode/utf8"
)

var (
   // Depending on autogenerated code we may use this. Add a reference
   // to shut the compiler up.
   _ = bytes.MinRead
   _ = fmt.Sprintf
   _ = utf16.Decode
   _ = binary.LittleEndian
   _ = utf8.RuneError
   _ = sort.Strings
   _ = strings.Join
   _ = io.Copy
)

func indent(text string) string {
    result := []string{}
    lines := strings.Split(text,"\n")
    for _, line := range lines {
         result = append(result, "  " + line)
    }
    return strings.Join(result, "\n")
}


type OLEProfile struct {
    Off_CFHeader_Signature int64
    Off_CFHeader_CLSID int64
    Off_CFHeader_MinorVersion int64
    Off_CFHeader_MajorVersion int64
    Off_CFHeader_SectorSize int64
    Off_CFHeader_MiniSectorShift int64
    Off_CFHeader_NumDirectorySectors int64
    Off_CFHeader_NumFATSectors int64
    Off_CFHeader_DirectorySectorLoc int64
    Off_CFHeader_MiniSectorCutoff int64
    Off_CFHeader_MiniFATSectorLoc int64
    Off_CFHeader_NumMiniFATSectors int64
    Off_CFHeader_DIFATSectorLoc int64
    Off_CFHeader_NumDIFATSectors int64
    Off_CFHeader_InitialDIFATs int64
    Off_DirectoryHeader_Name int64
    Off_DirectoryHeader_NameLength int64
    Off_DirectoryHeader_TypeInt int64
    Off_DirectoryHeader_Type int64
    Off_DirectoryHeader_Flags int64
    Off_DirectoryHeader_SidLeftSib int64
    Off_DirectoryHeader_SidRightSib int64
    Off_DirectoryHeader_SidChild int64
    Off_DirectoryHeader_ClsId int64
    Off_DirectoryHeader_UserFlags int64
    Off_DirectoryHeader_CreateTime int64
    Off_DirectoryHeader_ModifyTime int64
    Off_DirectoryHeader_SectorStart int64
    Off_DirectoryHeader_StreamSize int64
}

func NewOLEProfile() *OLEProfile {
    // Specific offsets can be tweaked to cater for slight version mismatches.
    self := &OLEProfile{0,8,24,26,30,32,40,44,48,56,60,64,68,72,76,0,64,66,66,67,68,72,76,80,96,100,108,116,120}
    return self
}

func (self *OLEProfile) CFHeader(reader io.ReaderAt, offset int64) *CFHeader {
    return &CFHeader{Reader: reader, Offset: offset, Profile: self}
}

func (self *OLEProfile) DirectoryHeader(reader io.ReaderAt, offset int64) *DirectoryHeader {
    return &DirectoryHeader{Reader: reader, Offset: offset, Profile: self}
}


type CFHeader struct {
    Reader io.ReaderAt
    Offset int64
    Profile *OLEProfile
}

func (self *CFHeader) Size() int {
    return 0
}

func (self *CFHeader) Signature() uint64 {
    return ParseUint64(self.Reader, self.Profile.Off_CFHeader_Signature + self.Offset)
}


func (self *CFHeader) CLSID() string {
  return ParseString(self.Reader, self.Profile.Off_CFHeader_CLSID + self.Offset, 16)
}

func (self *CFHeader) MinorVersion() uint16 {
   return ParseUint16(self.Reader, self.Profile.Off_CFHeader_MinorVersion + self.Offset)
}

func (self *CFHeader) MajorVersion() uint16 {
   return ParseUint16(self.Reader, self.Profile.Off_CFHeader_MajorVersion + self.Offset)
}

func (self *CFHeader) SectorSize() uint16 {
   return ParseUint16(self.Reader, self.Profile.Off_CFHeader_SectorSize + self.Offset)
}

func (self *CFHeader) MiniSectorShift() uint16 {
   return ParseUint16(self.Reader, self.Profile.Off_CFHeader_MiniSectorShift + self.Offset)
}

func (self *CFHeader) NumDirectorySectors() uint32 {
   return ParseUint32(self.Reader, self.Profile.Off_CFHeader_NumDirectorySectors + self.Offset)
}

func (self *CFHeader) NumFATSectors() uint32 {
   return ParseUint32(self.Reader, self.Profile.Off_CFHeader_NumFATSectors + self.Offset)
}

func (self *CFHeader) DirectorySectorLoc() uint32 {
   return ParseUint32(self.Reader, self.Profile.Off_CFHeader_DirectorySectorLoc + self.Offset)
}

func (self *CFHeader) MiniSectorCutoff() uint32 {
   return ParseUint32(self.Reader, self.Profile.Off_CFHeader_MiniSectorCutoff + self.Offset)
}

func (self *CFHeader) MiniFATSectorLoc() uint32 {
   return ParseUint32(self.Reader, self.Profile.Off_CFHeader_MiniFATSectorLoc + self.Offset)
}

func (self *CFHeader) NumMiniFATSectors() uint32 {
   return ParseUint32(self.Reader, self.Profile.Off_CFHeader_NumMiniFATSectors + self.Offset)
}

func (self *CFHeader) DIFATSectorLoc() uint32 {
   return ParseUint32(self.Reader, self.Profile.Off_CFHeader_DIFATSectorLoc + self.Offset)
}

func (self *CFHeader) NumDIFATSectors() uint32 {
   return ParseUint32(self.Reader, self.Profile.Off_CFHeader_NumDIFATSectors + self.Offset)
}

func (self *CFHeader) InitialDIFATs() []uint32 {
   return ParseArray_uint32(self.Profile, self.Reader, self.Profile.Off_CFHeader_InitialDIFATs + self.Offset, 109)
}
func (self *CFHeader) DebugString() string {
    result := fmt.Sprintf("struct CFHeader @ %#x:\n", self.Offset)
    result += fmt.Sprintf("  Signature: %#0x\n", self.Signature())
    result += fmt.Sprintf("  CLSID: %v\n", string(self.CLSID()))
    result += fmt.Sprintf("  MinorVersion: %#0x\n", self.MinorVersion())
    result += fmt.Sprintf("  MajorVersion: %#0x\n", self.MajorVersion())
    result += fmt.Sprintf("  SectorSize: %#0x\n", self.SectorSize())
    result += fmt.Sprintf("  MiniSectorShift: %#0x\n", self.MiniSectorShift())
    result += fmt.Sprintf("  NumDirectorySectors: %#0x\n", self.NumDirectorySectors())
    result += fmt.Sprintf("  NumFATSectors: %#0x\n", self.NumFATSectors())
    result += fmt.Sprintf("  DirectorySectorLoc: %#0x\n", self.DirectorySectorLoc())
    result += fmt.Sprintf("  MiniSectorCutoff: %#0x\n", self.MiniSectorCutoff())
    result += fmt.Sprintf("  MiniFATSectorLoc: %#0x\n", self.MiniFATSectorLoc())
    result += fmt.Sprintf("  NumMiniFATSectors: %#0x\n", self.NumMiniFATSectors())
    result += fmt.Sprintf("  DIFATSectorLoc: %#0x\n", self.DIFATSectorLoc())
    result += fmt.Sprintf("  NumDIFATSectors: %#0x\n", self.NumDIFATSectors())
    return result
}

type DirectoryHeader struct {
    Reader io.ReaderAt
    Offset int64
    Profile *OLEProfile
}

func (self *DirectoryHeader) Size() int {
    return 128
}


func (self *DirectoryHeader) Name() string {
  return ParseUTF16String(self.Reader, self.Profile.Off_DirectoryHeader_Name + self.Offset, 64)
}

func (self *DirectoryHeader) NameLength() uint16 {
   return ParseUint16(self.Reader, self.Profile.Off_DirectoryHeader_NameLength + self.Offset)
}

func (self *DirectoryHeader) TypeInt() byte {
   return ParseUint8(self.Reader, self.Profile.Off_DirectoryHeader_TypeInt + self.Offset)
}

func (self *DirectoryHeader) Type() *Enumeration {
   value := ParseUint8(self.Reader, self.Profile.Off_DirectoryHeader_Type + self.Offset)
   name := "Unknown"
   switch value {

      case 1:
         name = "Storage"

      case 2:
         name = "Stream"

      case 5:
         name = "Root"
}
   return &Enumeration{Value: uint64(value), Name: name}
}


func (self *DirectoryHeader) Flags() byte {
   return ParseUint8(self.Reader, self.Profile.Off_DirectoryHeader_Flags + self.Offset)
}

func (self *DirectoryHeader) SidLeftSib() uint32 {
   return ParseUint32(self.Reader, self.Profile.Off_DirectoryHeader_SidLeftSib + self.Offset)
}

func (self *DirectoryHeader) SidRightSib() uint32 {
   return ParseUint32(self.Reader, self.Profile.Off_DirectoryHeader_SidRightSib + self.Offset)
}

func (self *DirectoryHeader) SidChild() uint32 {
   return ParseUint32(self.Reader, self.Profile.Off_DirectoryHeader_SidChild + self.Offset)
}


func (self *DirectoryHeader) ClsId() string {
  return ParseString(self.Reader, self.Profile.Off_DirectoryHeader_ClsId + self.Offset, 16)
}

func (self *DirectoryHeader) UserFlags() uint32 {
   return ParseUint32(self.Reader, self.Profile.Off_DirectoryHeader_UserFlags + self.Offset)
}

func (self *DirectoryHeader) CreateTime() uint64 {
    return ParseUint64(self.Reader, self.Profile.Off_DirectoryHeader_CreateTime + self.Offset)
}

func (self *DirectoryHeader) ModifyTime() uint64 {
    return ParseUint64(self.Reader, self.Profile.Off_DirectoryHeader_ModifyTime + self.Offset)
}

func (self *DirectoryHeader) SectorStart() uint32 {
   return ParseUint32(self.Reader, self.Profile.Off_DirectoryHeader_SectorStart + self.Offset)
}

func (self *DirectoryHeader) StreamSize() uint64 {
    return ParseUint64(self.Reader, self.Profile.Off_DirectoryHeader_StreamSize + self.Offset)
}
func (self *DirectoryHeader) DebugString() string {
    result := fmt.Sprintf("struct DirectoryHeader @ %#x:\n", self.Offset)
    result += fmt.Sprintf("  Name: %v\n", string(self.Name()))
    result += fmt.Sprintf("  NameLength: %#0x\n", self.NameLength())
    result += fmt.Sprintf("  TypeInt: %#0x\n", self.TypeInt())
    result += fmt.Sprintf("  Type: %v\n", self.Type().DebugString())
    result += fmt.Sprintf("  Flags: %#0x\n", self.Flags())
    result += fmt.Sprintf("  SidLeftSib: %#0x\n", self.SidLeftSib())
    result += fmt.Sprintf("  SidRightSib: %#0x\n", self.SidRightSib())
    result += fmt.Sprintf("  SidChild: %#0x\n", self.SidChild())
    result += fmt.Sprintf("  ClsId: %v\n", string(self.ClsId()))
    result += fmt.Sprintf("  UserFlags: %#0x\n", self.UserFlags())
    result += fmt.Sprintf("  CreateTime: %#0x\n", self.CreateTime())
    result += fmt.Sprintf("  ModifyTime: %#0x\n", self.ModifyTime())
    result += fmt.Sprintf("  SectorStart: %#0x\n", self.SectorStart())
    result += fmt.Sprintf("  StreamSize: %#0x\n", self.StreamSize())
    return result
}

type Enumeration struct {
    Value uint64
    Name  string
}

func (self Enumeration) DebugString() string {
    return fmt.Sprintf("%s (%d)", self.Name, self.Value)
}


func ParseArray_uint32(profile *OLEProfile, reader io.ReaderAt, offset int64, count int) []uint32 {
    result := make([]uint32, 0, count)
    for i:=0; i<count; i++ {
      value := ParseUint32(reader, offset)
      result = append(result, value)
      offset += int64(4)
    }
    return result
}

func ParseUint16(reader io.ReaderAt, offset int64) uint16 {
	var buf [2]byte
	data := buf[:]
    _, err := reader.ReadAt(data, offset)
    if err != nil {
       return 0
    }
    return binary.LittleEndian.Uint16(data)
}

func ParseUint32(reader io.ReaderAt, offset int64) uint32 {
	var buf [4]byte
	data := buf[:]
    _, err := reader.ReadAt(data, offset)
    if err != nil {
       return 0
    }
    return binary.LittleEndian.Uint32(data)
}

func ParseUint64(reader io.ReaderAt, offset int64) uint64 {
	var buf [8]byte
	data := buf[:]
    _, err := reader.ReadAt(data, offset)
    if err != nil {
       return 0
    }
    return binary.LittleEndian.Uint64(data)
}

func ParseUint8(reader io.ReaderAt, offset int64) byte {
	var buf [1]byte
	data := buf[:]
    _, err := reader.ReadAt(data, offset)
    if err != nil {
       return 0
    }
    return data[0]
}

func ParseTerminatedString(reader io.ReaderAt, offset int64) string {
   var buf [1024]byte
   data := buf[:]
   n, err := reader.ReadAt(data, offset)
   if err != nil && err != io.EOF {
     return ""
   }
   idx := bytes.Index(data[:n], []byte{0})
   if idx < 0 {
      idx = n
   }
   return string(data[0:idx])
}

func ParseString(reader io.ReaderAt, offset int64, length int64) string {
   data := make([]byte, length)
   n, err := reader.ReadAt(data, offset)
   if err != nil && err != io.EOF {
      return ""
   }
   return string(data[:n])
}


func ParseTerminatedUTF16String(reader io.ReaderAt, offset int64) string {
   var buf [1024]byte
   data := buf[:]
   n, err := reader.ReadAt(data, offset)
   if err != nil && err != io.EOF {
     return ""
   }

   idx := bytes.Index(data[:n], []byte{0, 0})
   if idx < 0 {
      idx = n-1
   }
   if idx%2 != 0 {
      idx += 1
   }
   return UTF16BytesToUTF8(data[0:idx], binary.LittleEndian)
}

func ParseUTF16String(reader io.ReaderAt, offset int64, length int64) string {
   data := make([]byte, length)
   n, err := reader.ReadAt(data, offset)
   if err != nil && err != io.EOF {
     return ""
   }
   return UTF16BytesToUTF8(data[:n], binary.LittleEndian)
}

func UTF16BytesToUTF8(b []byte, o binary.ByteOrder) string {
	if len(b) < 2 {
		return ""
	}

	if b[0] == 0xff && b[1] == 0xfe {
		o = binary.BigEndian
		b = b[2:]
	} else if b[0] == 0xfe && b[1] == 0xff {
		o = binary.LittleEndian
		b = b[2:]
	}

	utf := make([]uint16, (len(b)+(2-1))/2)

	for i := 0; i+(2-1) < len(b); i += 2 {
		utf[i/2] = o.Uint16(b[i:])
	}
	if len(b)/2 < len(utf) {
		utf[len(utf)-1] = utf8.RuneError
	}

	return string(utf16.Decode(utf))
}


